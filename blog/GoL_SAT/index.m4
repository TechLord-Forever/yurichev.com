m4_include(`commons.m4')

_HEADER_HL1(`12-Mar-2017: Conwayâ€™s Game of Life and SAT solver')

_HL2(`Part I: reversing back state of "Game of Life".')

<p>How could we reverse back a known state of GoL?
This can be solved by brute-force, but this is extremely slow and inefficient.</p>

<p>Let's try to use SAT solver.</p>

<p>First, we need to define a function which will tell, if the new cell will be created/born, preserved/stay or died.
Quick refresher: cell is born if it has 3 neighbours, it stays alive if it has 2 or 3 neighbours, it dies in any other case.</p>

<p>This is how I can define a function reflecting state of a new cell in the next state:</p>

_PRE_BEGIN
if center==true:
	return popcnt2(neighbours) || popcnt3(neighbours)
if center==false
	return popcnt3(neighbours)
_PRE_END

<p>We can get rid of "if" construction:</p>

_PRE_BEGIN
result=(center=true && (popcnt2(neighbours) || popcnt3(neighbours))) || (center=false && popcnt3(neighbours))
_PRE_END

<p>... where "center" is state of central cell, "neighbours" are 8 neighbouring cells, popcnt2 is a function which
returns True if it has exactly 2 bits on input, popcnt3 is the same, but for 3 bits
(just like these were used in my "Minesweeper" example (_HTML_LINK_AS_IS(`https://yurichev.com/blog/minesweeper_SAT/'))).</p>

<p>Using Wolfram Mathematica, I first create all helper functions and truth table for the function, which returns "true",
if a cell must be present in the next state, or "false" if not:</p>

_PRE_BEGIN
In[1]:= popcount[n_Integer]:=IntegerDigits[n,2] // Total

In[2]:= popcount2[n_Integer]:=Equal[popcount[n],2]

In[3]:= popcount3[n_Integer]:=Equal[popcount[n],3]

In[4]:= newcell[center_Integer,neighbours_Integer]:=(center==1 && (popcount2[neighbours]|| popcount3[neighbours]))||
(center==0 && popcount3[neighbours])

In[13]:= NewCellIsTrue=Flatten[Table[Join[{center},PadLeft[IntegerDigits[neighbours,2],8]] ->
Boole[newcell[center, neighbours]],{neighbours,0,255},{center,0,1}]]

Out[13]= {{0,0,0,0,0,0,0,0,0}->0,
{1,0,0,0,0,0,0,0,0}->0,
{0,0,0,0,0,0,0,0,1}->0,
{1,0,0,0,0,0,0,0,1}->0,
{0,0,0,0,0,0,0,1,0}->0,
{1,0,0,0,0,0,0,1,0}->0,
{0,0,0,0,0,0,0,1,1}->0,
{1,0,0,0,0,0,0,1,1}->1,

...
_PRE_END

<p>Now we can create a CNF expression out of truth table:</p>

_PRE_BEGIN
In[14]:= BooleanConvert[BooleanFunction[NewCellIsTrue,{center,a,b,c,d,e,f,g,h}],"CNF"]
Out[14]= (!a||!b||!c||!d)&&(!a||!b||!c||!e)&&(!a||!b||!c||!f)&&(!a||!b||!c||!g)&&(!a||!b||!c||!h)&&(!a||!b||!d||!e)&&
(!a||!b||!d||!f)&&(!a||!b||!d||!g)&&(!a||!b||!d||!h)&&(!a||!b||!e||!f)&&(!a||!b||!e||!g)&&(!a||!b||!e||!h)&&
(!a||!b||!f||!g)&&(!a||!b||!f||!h)&&(!a||!b||!g||!h)&&(!a||!c||!d||!e)&&(!a||!c||!d||!f)&&(!a||!c||!d||!g)&&
(!a||!c||!d||!h)&&(!a||!c||!e||!f)&&(!a||!c||!e||!g)&&(!a||!c||!e||!h)&&(!a||!c||!f||!g)&&(!a||!c||!f||!h)&&

...
_PRE_END

<p>Also, we need a second function, "inverted" one, which will return "true" if the cell must be absent in the next state,
or "false" otherwise:</p>

_PRE_BEGIN
In[15]:= NewCellIsFalse=Flatten[Table[Join[{center},PadLeft[IntegerDigits[neighbours,2],8]] ->
Boole[Not[newcell[center, neighbours]]],{neighbours,0,255},{center,0,1}]]
Out[15]= {{0,0,0,0,0,0,0,0,0}->1,
{1,0,0,0,0,0,0,0,0}->1,
{0,0,0,0,0,0,0,0,1}->1,
{1,0,0,0,0,0,0,0,1}->1,
{0,0,0,0,0,0,0,1,0}->1,

...

In[16]:= BooleanConvert[BooleanFunction[NewCellIsFalse,{center,a,b,c,d,e,f,g,h}],"CNF"]
Out[16]= (!a||!b||!c||d||e||f||g||h)&&(!a||!b||c||!d||e||f||g||h)&&(!a||!b||c||d||!e||f||g||h)&&
(!a||!b||c||d||e||!f||g||h)&&(!a||!b||c||d||e||f||!g||h)&&(!a||!b||c||d||e||f||g||!h)&&
(!a||!b||!center||d||e||f||g||h)&&(!a||b||!c||!d||e||f||g||h)&&(!a||b||!c||d||!e||f||g||h)&&
(!a||b||!c||d||e||!f||g||h)&&(!a||b||!c||d||e||f||!g||h)&&(!a||b||!c||d||e||f||g||!h)&&
(!a||b||c||!d||!e||f||g||h)&&(!a||b||c||!d||e||!f||g||h)&&(!a||b||c||!d||e||f||!g||h)&&

...
_PRE_END

<p>Using the very same way as in my "Minesweeper" example, I can convert CNF expression to list of clauses:</p>

_PRE_BEGIN
def mathematica_to_CNF (s, center, a):
    s=s.replace("center", center)
    s=s.replace("a", a[0]).replace("b", a[1]).replace("c", a[2]).replace("d", a[3])
    s=s.replace("e", a[4]).replace("f", a[5]).replace("g", a[6]).replace("h", a[7])
    s=s.replace("!", "-").replace("||", " ").replace("(", "").replace(")", "")
    s=s.split ("&&")
    return s
_PRE_END

<p>And again, as in "Minesweeper", there is an invisible border, to make processing simpler.
SAT variables are also numbered as in previous example:</p>

_PRE_BEGIN
 1    2   3   4   5   6   7   8   9  10  11
12   13  14  15  16  17  18  19  20  21  22
23   24  25  26  27  28  29  30  31  32  33
34   35  36  37  38  39  40  41  42  43  44

...

100 101 102 103 104 105 106 107 108 109 110
111 112 113 114 115 116 117 118 119 120 121
_PRE_END

<p>Also, there is a visible border, always fixed to "False", to make things simpler.</p>

<p>Now the working source code.
Whenever we encounter "*" in final_state[], we add clauses generated by cell_is_true() function,
or cell_is_false() if otherwise.
When we get a solution, it is negated and added to the list of clauses, so when minisat is executed next time,
it will skip solution which was already printed.</p>

_PRE_BEGIN
#!/usr/bin/python

import os
from GoL_SAT_utils import *

final_state=[
"     ",
"  *  ",
" * * ",
"  *  ",
"     "]

HEIGHT=len(final_state)
WIDTH=len(final_state[0])

print "HEIGHT=", HEIGHT, "WIDTH=", WIDTH

VARS_TOTAL=(WIDTH+2)*(HEIGHT+2)

def coords_to_var (row, col):
    # we always use SAT variables as strings, anyway.
    # the 1st variables is 1, not 0
    return str(row*(WIDTH+2)+col+1)

def grid_to_clause(grid):
    rt=[]
    for r in range(HEIGHT):
        for c in range(WIDTH):
            rt.append(("-" if grid[r][c]==False else "") + str(coords_to_var(r+1, c+1)))
    return rt

def cell_is_true (center, a):
    s="(!a||!b||!c||!d)&&(!a||!b||!c||!e)&&(!a||!b||!c||!f)&&(!a||!b||!c||!g)&&(!a||!b||!c||!h)&&" \
      "(!a||!b||!d||!e)&&(!a||!b||!d||!f)&&(!a||!b||!d||!g)&&(!a||!b||!d||!h)&&(!a||!b||!e||!f)&&" \
      "(!a||!b||!e||!g)&&(!a||!b||!e||!h)&&(!a||!b||!f||!g)&&(!a||!b||!f||!h)&&(!a||!b||!g||!h)&&" \
      "(!a||!c||!d||!e)&&(!a||!c||!d||!f)&&(!a||!c||!d||!g)&&(!a||!c||!d||!h)&&(!a||!c||!e||!f)&&" \
      "(!a||!c||!e||!g)&&(!a||!c||!e||!h)&&(!a||!c||!f||!g)&&(!a||!c||!f||!h)&&(!a||!c||!g||!h)&&" \
      "(!a||!d||!e||!f)&&(!a||!d||!e||!g)&&(!a||!d||!e||!h)&&(!a||!d||!f||!g)&&(!a||!d||!f||!h)&&" \
      "(!a||!d||!g||!h)&&(!a||!e||!f||!g)&&(!a||!e||!f||!h)&&(!a||!e||!g||!h)&&(!a||!f||!g||!h)&&" \
      "(a||b||c||center||d||e||f)&&(a||b||c||center||d||e||g)&&(a||b||c||center||d||e||h)&&" \
      "(a||b||c||center||d||f||g)&&(a||b||c||center||d||f||h)&&(a||b||c||center||d||g||h)&&" \
      "(a||b||c||center||e||f||g)&&(a||b||c||center||e||f||h)&&(a||b||c||center||e||g||h)&&" \
      "(a||b||c||center||f||g||h)&&(a||b||c||d||e||f||g)&&(a||b||c||d||e||f||h)&&(a||b||c||d||e||g||h)&&" \
      "(a||b||c||d||f||g||h)&&(a||b||c||e||f||g||h)&&(a||b||center||d||e||f||g)&&(a||b||center||d||e||f||h)&&" \
      "(a||b||center||d||e||g||h)&&(a||b||center||d||f||g||h)&&(a||b||center||e||f||g||h)&&(a||b||d||e||f||g||h)&&" \
      "(a||c||center||d||e||f||g)&&(a||c||center||d||e||f||h)&&(a||c||center||d||e||g||h)&&" \
      "(a||c||center||d||f||g||h)&&(a||c||center||e||f||g||h)&&(a||c||d||e||f||g||h)&&(a||center||d||e||f||g||h)&&" \
      "(!b||!c||!d||!e)&&(!b||!c||!d||!f)&&(!b||!c||!d||!g)&&(!b||!c||!d||!h)&&(!b||!c||!e||!f)&&" \
      "(!b||!c||!e||!g)&&(!b||!c||!e||!h)&&(!b||!c||!f||!g)&&(!b||!c||!f||!h)&&(!b||!c||!g||!h)&&" \
      "(!b||!d||!e||!f)&&(!b||!d||!e||!g)&&(!b||!d||!e||!h)&&(!b||!d||!f||!g)&&(!b||!d||!f||!h)&&" \
      "(!b||!d||!g||!h)&&(!b||!e||!f||!g)&&(!b||!e||!f||!h)&&(!b||!e||!g||!h)&&(!b||!f||!g||!h)&&" \
      "(b||c||center||d||e||f||g)&&(b||c||center||d||e||f||h)&&(b||c||center||d||e||g||h)&&" \
      "(b||c||center||d||f||g||h)&&(b||c||center||e||f||g||h)&&(b||c||d||e||f||g||h)&&(b||center||d||e||f||g||h)&&" \
      "(!c||!d||!e||!f)&&(!c||!d||!e||!g)&&(!c||!d||!e||!h)&&(!c||!d||!f||!g)&&(!c||!d||!f||!h)&&" \
      "(!c||!d||!g||!h)&&(!c||!e||!f||!g)&&(!c||!e||!f||!h)&&(!c||!e||!g||!h)&&(!c||!f||!g||!h)&&" \
      "(c||center||d||e||f||g||h)&&(!d||!e||!f||!g)&&(!d||!e||!f||!h)&&(!d||!e||!g||!h)&&(!d||!f||!g||!h)&&" \
      "(!e||!f||!g||!h)"
    
    return mathematica_to_CNF(s, center, a)

def cell_is_false (center, a):
    s="(!a||!b||!c||d||e||f||g||h)&&(!a||!b||c||!d||e||f||g||h)&&(!a||!b||c||d||!e||f||g||h)&&" \
      "(!a||!b||c||d||e||!f||g||h)&&(!a||!b||c||d||e||f||!g||h)&&(!a||!b||c||d||e||f||g||!h)&&" \
      "(!a||!b||!center||d||e||f||g||h)&&(!a||b||!c||!d||e||f||g||h)&&(!a||b||!c||d||!e||f||g||h)&&" \
      "(!a||b||!c||d||e||!f||g||h)&&(!a||b||!c||d||e||f||!g||h)&&(!a||b||!c||d||e||f||g||!h)&&" \
      "(!a||b||c||!d||!e||f||g||h)&&(!a||b||c||!d||e||!f||g||h)&&(!a||b||c||!d||e||f||!g||h)&&" \
      "(!a||b||c||!d||e||f||g||!h)&&(!a||b||c||d||!e||!f||g||h)&&(!a||b||c||d||!e||f||!g||h)&&" \
      "(!a||b||c||d||!e||f||g||!h)&&(!a||b||c||d||e||!f||!g||h)&&(!a||b||c||d||e||!f||g||!h)&&" \
      "(!a||b||c||d||e||f||!g||!h)&&(!a||!c||!center||d||e||f||g||h)&&(!a||c||!center||!d||e||f||g||h)&&" \
      "(!a||c||!center||d||!e||f||g||h)&&(!a||c||!center||d||e||!f||g||h)&&(!a||c||!center||d||e||f||!g||h)&&" \
      "(!a||c||!center||d||e||f||g||!h)&&(a||!b||!c||!d||e||f||g||h)&&(a||!b||!c||d||!e||f||g||h)&&" \
      "(a||!b||!c||d||e||!f||g||h)&&(a||!b||!c||d||e||f||!g||h)&&(a||!b||!c||d||e||f||g||!h)&&" \
      "(a||!b||c||!d||!e||f||g||h)&&(a||!b||c||!d||e||!f||g||h)&&(a||!b||c||!d||e||f||!g||h)&&" \
      "(a||!b||c||!d||e||f||g||!h)&&(a||!b||c||d||!e||!f||g||h)&&(a||!b||c||d||!e||f||!g||h)&&" \
      "(a||!b||c||d||!e||f||g||!h)&&(a||!b||c||d||e||!f||!g||h)&&(a||!b||c||d||e||!f||g||!h)&&" \
      "(a||!b||c||d||e||f||!g||!h)&&(a||b||!c||!d||!e||f||g||h)&&(a||b||!c||!d||e||!f||g||h)&&" \
      "(a||b||!c||!d||e||f||!g||h)&&(a||b||!c||!d||e||f||g||!h)&&(a||b||!c||d||!e||!f||g||h)&&" \
      "(a||b||!c||d||!e||f||!g||h)&&(a||b||!c||d||!e||f||g||!h)&&(a||b||!c||d||e||!f||!g||h)&&" \
      "(a||b||!c||d||e||!f||g||!h)&&(a||b||!c||d||e||f||!g||!h)&&(a||b||c||!d||!e||!f||g||h)&&" \
      "(a||b||c||!d||!e||f||!g||h)&&(a||b||c||!d||!e||f||g||!h)&&(a||b||c||!d||e||!f||!g||h)&&" \
      "(a||b||c||!d||e||!f||g||!h)&&(a||b||c||!d||e||f||!g||!h)&&(a||b||c||d||!e||!f||!g||h)&&" \
      "(a||b||c||d||!e||!f||g||!h)&&(a||b||c||d||!e||f||!g||!h)&&(a||b||c||d||e||!f||!g||!h)&&" \
      "(!b||!c||!center||d||e||f||g||h)&&(!b||c||!center||!d||e||f||g||h)&&(!b||c||!center||d||!e||f||g||h)&&" \
      "(!b||c||!center||d||e||!f||g||h)&&(!b||c||!center||d||e||f||!g||h)&&(!b||c||!center||d||e||f||g||!h)&&" \
      "(b||!c||!center||!d||e||f||g||h)&&(b||!c||!center||d||!e||f||g||h)&&(b||!c||!center||d||e||!f||g||h)&&" \
      "(b||!c||!center||d||e||f||!g||h)&&(b||!c||!center||d||e||f||g||!h)&&(b||c||!center||!d||!e||f||g||h)&&" \
      "(b||c||!center||!d||e||!f||g||h)&&(b||c||!center||!d||e||f||!g||h)&&(b||c||!center||!d||e||f||g||!h)&&" \
      "(b||c||!center||d||!e||!f||g||h)&&(b||c||!center||d||!e||f||!g||h)&&(b||c||!center||d||!e||f||g||!h)&&" \
      "(b||c||!center||d||e||!f||!g||h)&&(b||c||!center||d||e||!f||g||!h)&&(b||c||!center||d||e||f||!g||!h)"

    return mathematica_to_CNF(s, center, a)

# FIXME: slow
def SAT_solution_to_grid(solution):
    grid=[[False for c in range(WIDTH)] for r in range(HEIGHT)]
    for r in range(1,HEIGHT+1):
        for c in range(1,WIDTH+1):
            v=coords_to_var(r, c)
            if v in solution:
                grid[r-1][c-1]=True
            if "-"+v in solution:
                grid[r-1][c-1]=False
    return grid

def try_again (clauses):
    # make an empty invisible border
    # all variables are negated (because they must be False)
    for c in range(WIDTH+2):
        clauses.append ("-"+coords_to_var(0,c))
        clauses.append ("-"+coords_to_var(HEIGHT+1,c))
    for r in range(HEIGHT+2):
        clauses.append ("-"+coords_to_var(r,0))
        clauses.append ("-"+coords_to_var(r,WIDTH+1))
   
    # make an empty visible border
    # all variables are negated (because they must be False)
    for c in range(1,WIDTH+1):
        clauses.append ("-"+coords_to_var(1,c))
        clauses.append ("-"+coords_to_var(HEIGHT,c))
    for r in range(1,HEIGHT+1):
        clauses.append ("-"+coords_to_var(r,1))
        clauses.append ("-"+coords_to_var(r,WIDTH))

    for r in range(1,HEIGHT+1):
        for c in range(1,WIDTH+1):
            neighbours=[coords_to_var(r-1, c-1), coords_to_var(r-1, c), coords_to_var(r-1, c+1), coords_to_var(r, c-1),
                            coords_to_var(r, c+1), coords_to_var(r+1, c-1), coords_to_var(r+1, c), coords_to_var(r+1, c+1)]
            if final_state[r-1][c-1]=="*":
                clauses=clauses+cell_is_true(coords_to_var(r, c), neighbours)
            else:
                clauses=clauses+cell_is_false(coords_to_var(r, c), neighbours)

    write_CNF("tmp.cnf", clauses, VARS_TOTAL)

    print "%d clauses" % len(clauses)

    solution=run_minisat ("tmp.cnf")
    os.remove("tmp.cnf")
    if solution==None:
        print "unsat!"
        exit(0)
    
    grid=SAT_solution_to_grid(solution)

    print_grid(grid)
    write_RLE(grid)

    return grid

clauses=[]
while True:
    solution=try_again(clauses)
    clauses.append(negate_clause(grid_to_clause(solution)))
    print ""
_PRE_END

<p>Here is a result:</p>

_PRE_BEGIN
HEIGHT= 5 WIDTH= 5
2236 clauses
.....
..*..
.*.*.
..*..
.....
1.rle written

2285 clauses
.....
..**.
.*...
.*.*.
.....
2.rle written

2334 clauses
.....
.**..
...*.
.*.*.
.....
3.rle written

2383 clauses
.....
.*.*.
.*...
..**.
.....
4.rle written

2432 clauses
.....
.*.*.
...*.
.**..
.....
5.rle written

2481 clauses
.....
.*.*.
..*..
.*.*.
.....
6.rle written

2530 clauses
unsat!
_PRE_END

<p>The first result is the same as input state.
Indeed: this is "still life", i.e., state which will never change, and it is correct solution.
The last solution is also valid.</p>

<p>Now the problem: 2nd, 3rd, 4th and 5th solutions are equivalent to each other, they just mirrored or rotated.
In fact, this is _HTML_LINK(`https://en.wikipedia.org/wiki/Reflection_symmetry',`reflectional') (like in mirror) and _HTML_LINK(`https://en.wikipedia.org/wiki/Rotational_symmetry',`rotational') symmetries.
We can solve this easily: we will take each solution, reflect and rotate it and add them negated to the list of clauses,
so minisat will skip them during its work:</p>

_PRE_BEGIN
clauses=[]
while True:
    solution=try_again(clauses)
    clauses.append(negate_clause(grid_to_clause(solution)))
    clauses.append(negate_clause(grid_to_clause(reflect_vertically(solution))))
    clauses.append(negate_clause(grid_to_clause(reflect_horizontally(solution))))
    # is this square?
    if WIDTH==HEIGHT:
        clauses.append(negate_clause(grid_to_clause(rotate_square_array(solution,1))))
        clauses.append(negate_clause(grid_to_clause(rotate_square_array(solution,2))))
        clauses.append(negate_clause(grid_to_clause(rotate_square_array(solution,3))))
    print ""
_PRE_END

<p>Functions reflect_vertically(), reflect_horizontally and rotate_square_array() are simple array manipulation routines.</p>

<p>Now we get just 3 solutions:</p>

_PRE_BEGIN
HEIGHT= 5 WIDTH= 5
2236 clauses
.....
..*..
.*.*.
..*..
.....
1.rle written

2290 clauses
.....
..**.
.*...
.*.*.
.....
2.rle written

2344 clauses
.....
.*.*.
..*..
.*.*.
.....
3.rle written

2398 clauses
unsat!
_PRE_END

<p>This one has only one single ancestor:</p>

_PRE_BEGIN
final_state=[
"     ",
"  *  ",
"  *  ",
"  *  ",
"     "]
_PRE_END

_PRE_BEGIN
HEIGHT= 5 WIDTH= 5
2214 clauses
.....
.....
.***.
.....
.....
1.rle written

2268 clauses
unsat!
_PRE_END

<p>This is oscillator, of course.</p>

<p>How many states can lead to such picture?</p>

_PRE_BEGIN
final_state=[
"       ",
"   *   ",
"       ",
"  **   ",
"   *   ",
"   *   ",
"  ***  ",
"       "]
_PRE_END

<p>28, these are few:</p>

_PRE_BEGIN
HEIGHT= 8 WIDTH= 7
4948 clauses
.......
..*.*..
...*...
..**.*.
...*...
...*.*.
..**...
.......
1.rle written

5019 clauses
.......
..*.*..
...*...
..**.*.
...*...
.*.*.*.
..**...
.......
2.rle written

5090 clauses
.......
...*.*.
...**..
..**...
.....*.
.*.*.*.
..**...
.......
3.rle written

...
_PRE_END

<p>Now the biggest, "space invader":</p>

_PRE_BEGIN
final_state=[
"               ",
"               ",
"    *     *    ",
"     *   *     ",
"    *******    ",
"   ** *** **   ",
"  ***********  ",
"  * ******* *  ",
"  * *     * *  ",
"     ** **     ",
"               ",
"               "]
_PRE_END

_PRE_BEGIN
HEIGHT= 12 WIDTH= 15
16248 clauses
...............
...*.......*...
.....*...*.....
...*.......*...
....**...**....
..*.*.***.*.*..
...............
.*.*.*...*.*.*.
.*..*.***.*..*.
.....**.**.....
..*............
...............
1.rle written

16367 clauses
...............
...*..*....*...
.....*...*.....
...*.......*...
....**...**....
..*.*.***.*.*..
...............
.*.*.*...*.*.*.
.*..*.***.*..*.
.....**.**.....
..*............
...............
2.rle written

16486 clauses
...............
...*...*...*...
.....*...*.....
...*.......*...
....**...**....
..*.*.***.*.*..
...............
.*.*.*...*.*.*.
.*..*.***.*..*.
.....**.**.....
..*............
...............
3.rle written

...
_PRE_END

<p>I don't know how many possible input states can lead to "space invader", perhaps, too many.
Had to stop it.
And it slows down during execution, because number of clauses is increasing (because of negating solutions addition).</p>

<p>All solutions are also exported to RLE files, which can be opened by Golly (_HTML_LINK_AS_IS(`http://golly.sourceforge.net/')) software.</p>

_HL2(`Part II: finding "still lives"')

<p>"Still life" in terms of GoL is a state which doesn't change at all.</p>

<p>First, using previous definitions, we will define a truth table of function, which will return true,
if the center cell of the next state is the same as it has been in the previous state, i.e., hasn't been changed:</p>

_PRE_BEGIN
In[17]:= stillife=Flatten[Table[Join[{center},PadLeft[IntegerDigits[neighbours,2],8]]->
Boole[Boole[newcell[center,neighbours]]==center],{neighbours,0,255},{center,0,1}]]
Out[17]= {{0,0,0,0,0,0,0,0,0}->1,
{1,0,0,0,0,0,0,0,0}->0,
{0,0,0,0,0,0,0,0,1}->1,
{1,0,0,0,0,0,0,0,1}->0,

...

In[18]:= BooleanConvert[BooleanFunction[stillife,{center,a,b,c,d,e,f,g,h}],"CNF"]
Out[18]= (!a||!b||!c||!center||!d)&&(!a||!b||!c||!center||!e)&&(!a||!b||!c||!center||!f)&&
(!a||!b||!c||!center||!g)&&(!a||!b||!c||!center||!h)&&(!a||!b||!c||center||d||e||f||g||h)&&
(!a||!b||c||center||!d||e||f||g||h)&&(!a||!b||c||center||d||!e||f||g||h)&&(!a||!b||c||center||d||e||!f||g||h)&&
(!a||!b||c||center||d||e||f||!g||h)&&(!a||!b||c||center||d||e||f||g||!h)&&(!a||!b||!center||!d||!e)&&

...

_PRE_END

_PRE_BEGIN
#!/usr/bin/python

import os
from GoL_SAT_utils import *

WIDTH=4
HEIGHT=4
VARS_TOTAL=(WIDTH+2)*(HEIGHT+2)

def stillife (center, a):
    s="(!a||!b||!c||!center||!d)&&(!a||!b||!c||!center||!e)&&(!a||!b||!c||!center||!f)&&(!a||!b||!c||!center||!g)&&" \
      "(!a||!b||!c||!center||!h)&&(!a||!b||!c||center||d||e||f||g||h)&&(!a||!b||c||center||!d||e||f||g||h)&&" \
      "(!a||!b||c||center||d||!e||f||g||h)&&(!a||!b||c||center||d||e||!f||g||h)&&(!a||!b||c||center||d||e||f||!g||h)&&" \
      "(!a||!b||c||center||d||e||f||g||!h)&&(!a||!b||!center||!d||!e)&&(!a||!b||!center||!d||!f)&&" \
      "(!a||!b||!center||!d||!g)&&(!a||!b||!center||!d||!h)&&(!a||!b||!center||!e||!f)&&(!a||!b||!center||!e||!g)&&" \
      "(!a||!b||!center||!e||!h)&&(!a||!b||!center||!f||!g)&&(!a||!b||!center||!f||!h)&&(!a||!b||!center||!g||!h)&&" \
      "(!a||b||!c||center||!d||e||f||g||h)&&(!a||b||!c||center||d||!e||f||g||h)&&(!a||b||!c||center||d||e||!f||g||h)&&" \
      "(!a||b||!c||center||d||e||f||!g||h)&&(!a||b||!c||center||d||e||f||g||!h)&&(!a||b||c||center||!d||!e||f||g||h)&&" \
      "(!a||b||c||center||!d||e||!f||g||h)&&(!a||b||c||center||!d||e||f||!g||h)&&(!a||b||c||center||!d||e||f||g||!h)&&" \
      "(!a||b||c||center||d||!e||!f||g||h)&&(!a||b||c||center||d||!e||f||!g||h)&&(!a||b||c||center||d||!e||f||g||!h)&&" \
      "(!a||b||c||center||d||e||!f||!g||h)&&(!a||b||c||center||d||e||!f||g||!h)&&(!a||b||c||center||d||e||f||!g||!h)&&" \
      "(!a||!c||!center||!d||!e)&&(!a||!c||!center||!d||!f)&&(!a||!c||!center||!d||!g)&&(!a||!c||!center||!d||!h)&&" \
      "(!a||!c||!center||!e||!f)&&(!a||!c||!center||!e||!g)&&(!a||!c||!center||!e||!h)&&(!a||!c||!center||!f||!g)&&" \
      "(!a||!c||!center||!f||!h)&&(!a||!c||!center||!g||!h)&&(!a||!center||!d||!e||!f)&&(!a||!center||!d||!e||!g)&&" \
      "(!a||!center||!d||!e||!h)&&(!a||!center||!d||!f||!g)&&(!a||!center||!d||!f||!h)&&(!a||!center||!d||!g||!h)&&" \
      "(!a||!center||!e||!f||!g)&&(!a||!center||!e||!f||!h)&&(!a||!center||!e||!g||!h)&&(!a||!center||!f||!g||!h)&&" \
      "(a||!b||!c||center||!d||e||f||g||h)&&(a||!b||!c||center||d||!e||f||g||h)&&(a||!b||!c||center||d||e||!f||g||h)&&" \
      "(a||!b||!c||center||d||e||f||!g||h)&&(a||!b||!c||center||d||e||f||g||!h)&&(a||!b||c||center||!d||!e||f||g||h)&&" \
      "(a||!b||c||center||!d||e||!f||g||h)&&(a||!b||c||center||!d||e||f||!g||h)&&(a||!b||c||center||!d||e||f||g||!h)&&" \
      "(a||!b||c||center||d||!e||!f||g||h)&&(a||!b||c||center||d||!e||f||!g||h)&&(a||!b||c||center||d||!e||f||g||!h)&&" \
      "(a||!b||c||center||d||e||!f||!g||h)&&(a||!b||c||center||d||e||!f||g||!h)&&(a||!b||c||center||d||e||f||!g||!h)&&" \
      "(a||b||!c||center||!d||!e||f||g||h)&&(a||b||!c||center||!d||e||!f||g||h)&&(a||b||!c||center||!d||e||f||!g||h)&&" \
      "(a||b||!c||center||!d||e||f||g||!h)&&(a||b||!c||center||d||!e||!f||g||h)&&(a||b||!c||center||d||!e||f||!g||h)&&" \
      "(a||b||!c||center||d||!e||f||g||!h)&&(a||b||!c||center||d||e||!f||!g||h)&&(a||b||!c||center||d||e||!f||g||!h)&&" \
      "(a||b||!c||center||d||e||f||!g||!h)&&(a||b||c||!center||d||e||f||g)&&(a||b||c||!center||d||e||f||h)&&" \
      "(a||b||c||!center||d||e||g||h)&&(a||b||c||!center||d||f||g||h)&&(a||b||c||!center||e||f||g||h)&&" \
      "(a||b||c||center||!d||!e||!f||g||h)&&(a||b||c||center||!d||!e||f||!g||h)&&(a||b||c||center||!d||!e||f||g||!h)&&" \
      "(a||b||c||center||!d||e||!f||!g||h)&&(a||b||c||center||!d||e||!f||g||!h)&&(a||b||c||center||!d||e||f||!g||!h)&&" \
      "(a||b||c||center||d||!e||!f||!g||h)&&(a||b||c||center||d||!e||!f||g||!h)&&(a||b||c||center||d||!e||f||!g||!h)&&" \
      "(a||b||c||center||d||e||!f||!g||!h)&&(a||b||!center||d||e||f||g||h)&&(a||c||!center||d||e||f||g||h)&&" \
      "(!b||!c||!center||!d||!e)&&(!b||!c||!center||!d||!f)&&(!b||!c||!center||!d||!g)&&(!b||!c||!center||!d||!h)&&" \
      "(!b||!c||!center||!e||!f)&&(!b||!c||!center||!e||!g)&&(!b||!c||!center||!e||!h)&&(!b||!c||!center||!f||!g)&&" \
      "(!b||!c||!center||!f||!h)&&(!b||!c||!center||!g||!h)&&(!b||!center||!d||!e||!f)&&(!b||!center||!d||!e||!g)&&" \
      "(!b||!center||!d||!e||!h)&&(!b||!center||!d||!f||!g)&&(!b||!center||!d||!f||!h)&&(!b||!center||!d||!g||!h)&&" \
      "(!b||!center||!e||!f||!g)&&(!b||!center||!e||!f||!h)&&(!b||!center||!e||!g||!h)&&(!b||!center||!f||!g||!h)&&" \
      "(b||c||!center||d||e||f||g||h)&&(!c||!center||!d||!e||!f)&&(!c||!center||!d||!e||!g)&&(!c||!center||!d||!e||!h)&&" \
      "(!c||!center||!d||!f||!g)&&(!c||!center||!d||!f||!h)&&(!c||!center||!d||!g||!h)&&(!c||!center||!e||!f||!g)&&" \
      "(!c||!center||!e||!f||!h)&&(!c||!center||!e||!g||!h)&&(!c||!center||!f||!g||!h)&&(!center||!d||!e||!f||!g)&&" \
      "(!center||!d||!e||!f||!h)&&(!center||!d||!e||!g||!h)&&(!center||!d||!f||!g||!h)&&(!center||!e||!f||!g||!h)"

    return mathematica_to_CNF(s, center, a)

def coords_to_var (row, col):
    # we always use SAT variables as strings, anyway.
    # the 1st variables is 1, not 0
    return str(row*(WIDTH+2)+col+1)

# FIXME: slow
def SAT_solution_to_grid(solution):
    grid=[[False for c in range(WIDTH)] for r in range(HEIGHT)]
    for r in range(1,HEIGHT+1):
        for c in range(1,WIDTH+1):
            v=coords_to_var(r, c)
            if v in solution:
                grid[r-1][c-1]=True
            if "-"+v in solution:
                grid[r-1][c-1]=False
    return grid

def grid_to_clause(grid):
    rt=[]
    for r in range(HEIGHT):
        for c in range(WIDTH):
            rt.append(("-" if grid[r][c]==False else "") + str(coords_to_var(r+1, c+1)))
    return rt

def try_again (clauses):
    # make an empty invisible border
    # all variables are negated (because they must be False)
    for c in range(WIDTH+2):
        clauses.append ("-"+coords_to_var(0,c))
        clauses.append ("-"+coords_to_var(HEIGHT+1,c))
    for r in range(HEIGHT+2):
        clauses.append ("-"+coords_to_var(r,0))
        clauses.append ("-"+coords_to_var(r,WIDTH+1))
   
    # make an empty visible border
    # all variables are negated (because they must be False)
    for c in range(1,WIDTH+1):
        clauses.append ("-"+coords_to_var(1,c))
        clauses.append ("-"+coords_to_var(HEIGHT,c))
    for r in range(1,HEIGHT+1):
        clauses.append ("-"+coords_to_var(r,1))
        clauses.append ("-"+coords_to_var(r,WIDTH))

    for r in range(1,HEIGHT+1):
        for c in range(1,WIDTH+1):
            neighbours=[coords_to_var(r-1, c-1), coords_to_var(r-1, c), coords_to_var(r-1, c+1), coords_to_var(r, c-1),
                            coords_to_var(r, c+1), coords_to_var(r+1, c-1), coords_to_var(r+1, c), coords_to_var(r+1, c+1)]
            clauses=clauses+stillife(coords_to_var(r, c), neighbours)
   
    write_CNF("tmp.cnf", clauses, VARS_TOTAL)

    print "%d clauses" % len(clauses)

    solution=run_minisat ("tmp.cnf")
    os.remove("tmp.cnf")
    if solution==None:
        print "unsat!"
        exit(0)
    
    grid=SAT_solution_to_grid(solution)
    print_grid(grid)
    write_RLE(grid)

    return grid

clauses=[]
while True:
    solution=try_again(clauses)
    clauses.append(negate_clause(grid_to_clause(solution)))
    clauses.append(negate_clause(grid_to_clause(reflect_vertically(solution))))
    clauses.append(negate_clause(grid_to_clause(reflect_horizontally(solution))))
    # is this square?
    if WIDTH==HEIGHT:
        clauses.append(negate_clause(grid_to_clause(rotate_square_array(solution,1))))
        clauses.append(negate_clause(grid_to_clause(rotate_square_array(solution,2))))
        clauses.append(negate_clause(grid_to_clause(rotate_square_array(solution,3))))
    print ""
_PRE_END

<p>What we've got for 4*4 square (or 2*2 square if not to consider visible border)?</p>

_PRE_BEGIN
2184 clauses
....
....
....
....
1.rle written

2230 clauses
....
.**.
.**.
....
2.rle written

2276 clauses
unsat!
_PRE_END

<p>Both solutions are correct: empty square will progress into empty square (no cells are born).
2*2 box is also known still life.</p>

<p>What about 5*5 square?</p>

_PRE_BEGIN
3398 clauses
.....
.....
.....
.....
.....
1.rle written

3452 clauses
.....
..**.
..**.
.....
.....
2.rle written

3506 clauses
.....
..**.
.*.*.
.**..
.....
3.rle written

...
_PRE_END

<p>Here is a problem: we see familiar 2*2 box, but shifted.
This is indeed correct solution, but we don't interested in it, because it has been already seen.</p>

<p>What we can do is add another condition. We can force minisat to find solutions with no empty rows and columns.
This is easy.
These are SAT variables for 5*5 square:</p>

_PRE_BEGIN
1   2  3  4  5
6   7  8  9 10
11 12 13 14 15
16 17 18 19 20
21 22 23 24 25
_PRE_END

<p>Each clause is "OR" clause, so all we have to do is to add 5 clauses:</p>

_PRE_BEGIN
1 OR 2 OR 3 OR 4 OR 5
6 OR 7 OR 8 OR 9 OR 10

...
_PRE_END

<p>That means that each row must have at least one "True" variable somewhere.
We can also do this for each column as well.</p>

_PRE_BEGIN    
    # each row must contain at least one cell!
    for r in range(2,HEIGHT):
        clauses.append(" ".join([coords_to_var(r, c) for c in range(2, WIDTH)]))

    # each column must contain at least one cell!
    for c in range(2,WIDTH):
        clauses.append(" ".join([coords_to_var(r, c) for r in range(2, HEIGHT)]))
_PRE_END

<p>Now we can see that 5*5 (or 3*3 with no borders) square has 3 possible still lives:</p>

_PRE_BEGIN
3404 clauses
.....
..*..
.*.*.
.**..
.....
1.rle written

3458 clauses
.....
..*..
.*.*.
..*..
.....
2.rle written

3512 clauses
.....
..**.
.*.*.
.**..
.....
3.rle written

3566 clauses
unsat!
_PRE_END

<p>6*6 has 7:</p>

_PRE_BEGIN
4888 clauses
......
...**.
....*.
.***..
.*....
......
1.rle written

4950 clauses
......
...**.
...*..
.*.*..
.**...
......
2.rle written

5012 clauses
......
...**.
..*.*.
.*.*..
.**...
......
3.rle written

5074 clauses
......
...*..
..*.*.
.*.*..
.**...
......
4.rle written

5136 clauses
......
..**..
.*..*.
.*.*..
..*...
......
5.rle written

5198 clauses
......
...*..
..*.*.
.*.*..
..*...
......
6.rle written

5260 clauses
......
..**..
.*..*.
.*..*.
..**..
......
7.rle written

5322 clauses
unsat!
_PRE_END

<p>When I try large squares, like 20*20, funny things happen.
First of all, minisat finds solutions not very pleasing aesthetically, but still correct, like:</p>

_PRE_BEGIN
53804 clauses
....................
...**.**.**.**.**.*.
...*.**.**.**.**.**.
.**.................
.*..................
..*.................
.**.................
.*..................
..*.................
.**.................
.*..................
..*.................
.**.................
.*..................
..*.................
...*................
....*...............
.***................
.*..................
....................
1.rle written
_PRE_END

<p>Indeed: all rows and columns has at least one "True" variable.</p>

<p>Then minisat begins to add smaller "still lives" into the whole picture:</p>

_PRE_BEGIN
54500 clauses
....................
....**..**..**.**.*.
..*.*.*..*..*.**.**.
..*....**...........
.**.................
..................*.
.**.............***.
.*.............*....
..*.............***.
.**...............*.
.*..................
..*.................
.**.................
.*..................
..*......**.*.......
...*.....*.**.......
....*...............
.***................
.*..................
....................
5.rle written
_PRE_END

<p>It then altering these parts slightly, shifting back and forth.
Is it cheating?
Anyway, it does it in a strict accordance to rules we defined.</p>

_HL2(`Source code')

<p>Source code and Wolfram Mathematica notebook: _HTML_LINK_AS_IS(`https://github.com/dennis714/yurichev.com/tree/master/blog/GoL_SAT').</p>

_BLOG_FOOTER()

